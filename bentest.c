#pragma config(Motor,  motorA,          lift,          tmotorNXT, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "FTC_PID.c";
#include "FTC_ValueUtils.h"

PID m;
int Position[4] = {0,2000,4000,5000};//set targets
short targetNum = 0;//Used for Position array
short direction = 0;// 0 = not moving; 1 = moving up; 2 = moving down;

int getHalfway(int tar,int dir){
		switch(dir){
			case 1://if moving up
				return (Position[tar] + Position[tar--]) / 2;//get halfway point from target and lower target
			case 2://if moving down
				return (Position[tar] + Position[tar++]) / 2;//get halfway point from target and higher target
			default:
				return 0;//you broke something
		}
}

int getLastTarget(int pos, int dir){
	for ( int i = 0; i < sizeof(Position)/2; i++ ){
		if ( Position[i] < Position[i+1] && (i%2)  ){
			switch(dir){
			case 1://moving up
				return i;//return lower value from range
			case 2://moving down;
				return i++;//return higher value from range
			default:
				return 0;//you broke something
   			}
   		}
   	}
   	return 0;
}

task main()
{
	initPID(m ,1,0,0);
	m.target = 0;
	nMotorEncoder[lift] = 0;
	waitForStart();
	while(true){
		getJoystickSettings(joystick);
		if(joy1Btn(2)){
			direction = 3;
			targetNum = 0;
			m.target = nMotorEncoder[lift];
		}
		switch(direction){//check if moving
			case 0://not moving
				if(joystick.joy1_y1 >= 10){//if joystick is pushed up
					direction = 1;
					targetNum = (targetNum < sizeof(Position)/2-1 ? targetNum+1:2);
				}
				if(joystick.joy1_y1 <= -10 ){//if joystick is pushed down
					direction = 2;
					targetNum = (targetNum > 0 ? targetNum-1:0);
				}
				m.target = Position[targetNum];
				break;
			case 1://moving up
				if(dbc(joystick.joy1_y1,10) == 0){//if joystick is not pushed
					if(dbc(nMotorEncoder[lift] - Position[targetNum],7) == 0){
						direction = 0;
						break;
					}
				}
				if(joystick.joy1_y1>= 10){//if joystick is pushed up
					if(getHalfway(targetNum,direction) < nMotorEncoder[lift]){//check if past half way point
						targetNum = (targetNum < sizeof(Position)/2-1 ? targetNum+1:sizeof(Position)/2-1);
						m.target = Position[targetNum];
					}
					break;
				}
				if(joystick.joy1_y1 <= -10 ){//if joystick is pushed down
					targetNum = getLastTarget(nMotorEncoder[lift],direction);
					m.target = Position[targetNum];
					direction = 3;
				}
				break;
			case 2://moving down
				if(joystick.joy1_y1>= 10){//if joystick is pushed up
					targetNum = getLastTarget(nMotorEncoder[lift],direction);
					m.target = Position[targetNum];
					direction = 3;
					break;
				}
				if(joystick.joy1_y1 <= -10 ){//if joystick is pushed down
					if((Position[targetNum+1] + Position[targetNum]) / 2 > nMotorEncoder[lift]){//check if past half way point
						targetNum = (targetNum > 0 ? targetNum-1:0);
						m.target = Position[targetNum];
					}
					break;
				}
				if(dbc(joystick.joy1_y1,10) == 0){//if joystick is not pushed
					if(dbc(nMotorEncoder[lift] - Position[targetNum],7) == 0){
						direction = 0;
					}
				}
				break;
			case 3:
				if ( dbc(joystick.joy1_y1, 10) != 0 )
					direction = 0;
				break;
		}
		motor[lift] = calcPID(m,nMotorEncoder[lift]);
		nxtDisplayString(0,"target:%i",m.target);
		nxtDisplayString(1,"isAt:%i",nMotorEncoder[lift]);
		nxtDisplayString(2,"controller:%i",joystick.joy1_y1);
		nxtDisplayString(3,"targetNum:%i",targetNum);
		nxtDisplayString(4,"direction:%i",direction);
		nxtDisplayString(5,"Halfway:%i",getHalfway(targetNum,direction));
	}
}
